# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/preprocessing.ipynb.

# %% auto 0
__all__ = ['PolyImputer']

# %% ../nbs/preprocessing.ipynb 0
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import wasserstein_distance
from sklearn.base import BaseEstimator, TransformerMixin
from sklearn.pipeline import Pipeline

# %% ../nbs/preprocessing.ipynb 1
class PolyImputer(BaseEstimator, TransformerMixin):
    def __init__(self, data_columns, degrees=np.arange(2,7), plot=False):
        self.data_columns = data_columns
        self.degrees = degrees
        self.plot = plot
        self.poly_func = {}
        

    def fit(self, X, y=None):
        for column in self.data_columns:
            if X[column].isna().sum() == 0:
                continue
            else:
                self.poly_func[column] = self._find_best_polynomial(X[column])
        return self
    

    def transform(self, X):
        if self.poly_func is None:
            raise ValueError("PolyImputer must be fitted before calling transform.")
        
        for column in self.poly_func.keys():
            values = np.arange(len(X[column]))
            fill_value = pd.Series(self.poly_func[column](values), dtype=np.float32)
            X[column] = X[column].fillna(fill_value)
        return X
    

    def _find_best_polynomial(self, series):
        series_interpolated = series.interpolate(method='linear', limit_direction='both')
        x = np.arange(len(series_interpolated))
        y = series_interpolated.values
        dist = np.inf
        best_polynomial = None
        
        for degree in self.degrees:
            coefficients = np.polyfit(x, y, degree)
            polynomial = np.poly1d(coefficients)
            distribution = polynomial(x)

            wasserstein_dist = wasserstein_distance(series_interpolated, distribution)
            if wasserstein_dist < dist:
                best_polynomial = polynomial
                dist = wasserstein_dist                

        if self.plot:
            self._plot_polynomial_fit(distribution, series, dist, polynomial)

        return best_polynomial
    
    
    def _plot_polynomial_fit(self, distribution, original_series, dist, polynomial):
        _, ax = plt.subplots(figsize=(20, 5))
        ax.plot(original_series.index, distribution, label=f'Degree {polynomial.order}', linewidth=2)
        ax.scatter(original_series.index, original_series, c='grey', s=10)
        
        ax.legend()
        ax.set_title(f'Polynomial fit of {original_series.name}')
        ax.set_ylim(bottom=0)
        ax.annotate(f'Degree {polynomial.order} Wasserstein distance: {dist}', xy=(0, 20))
