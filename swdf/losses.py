# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/losses.ipynb.

# %% auto 0
__all__ = ['Loss', 'wMSELoss', 'wMAELoss', 'wMSLELoss', 'wHubberLoss', 'ClassificationLoss', 'TrendedLoss', 'LossMetrics']

# %% ../nbs/losses.ipynb 0
import torch
import numpy as np
import pandas as pd
from tsai.basics import *

# %% ../nbs/losses.ipynb 3
class Loss(nn.Module):
    def __init__(self, ranges, weights, solact_levels):
        super().__init__()
        self.register_buffer('ranges', torch.Tensor(ranges))
        self.register_buffer('weights', torch.Tensor(weights))
        self.solact_levels = solact_levels

    def weighted_loss_tensor(self, target):        
        batch, variables, horizon = target.shape  # Example shape (32, 4, 6)
        variable, range, interval = self.ranges.shape  # Example shape (4, 4, 2)

        target_shaped = torch.reshape(target, (batch, variables, 1, horizon))  # Example shape (32, 4, 6) -> (32, 4, 1, 6)
        ranges_shaped = torch.reshape(self.ranges, (variable, range, 1, interval))  # Example shape (4, 4, 2) -> (4, 4, 1, 2)

        weights_tensor = ((ranges_shaped[..., 0] <= target_shaped) & (target_shaped <= ranges_shaped[..., 1])).float()
        
        return torch.einsum('r,bvrh->bvh', self.weights, weights_tensor)
    
    def loss_measure(self, y_pred, y_true):
        return NotImplementedError
    
    def forward(self, y_pred, y_true):
        error = self.loss_measure(y_pred, y_true)
        weights = self.weighted_loss_tensor(y_true)
        loss = (error * weights).mean()
        
        return loss

# %% ../nbs/losses.ipynb 5
class wMSELoss(Loss):
    def __init__(self, ranges, weights, solact_levels):
        super().__init__(ranges, weights, solact_levels)

    
    def loss_measure(self, y_pred, y_true):
        return (y_true-y_pred)**2

# %% ../nbs/losses.ipynb 6
class wMAELoss(Loss):
    def __init__(self, ranges, weights, solact_levels):
        super().__init__(ranges, weights, solact_levels)

    
    def loss_measure(self, y_pred, y_true):
        return torch.abs(y_true-y_pred)

# %% ../nbs/losses.ipynb 7
class wMSLELoss(Loss):
    def __init__(self, ranges, weights, solact_levels):
        super().__init__(ranges, weights, solact_levels)
    
    def loss_measure(self, y_pred, y_true):
        return (torch.log1p(y_true) - torch.log1p(y_pred)) ** 2

# %% ../nbs/losses.ipynb 8
class wHubberLoss(Loss):
    def __init__(self, ranges, weights, solact_levels, delta=2.0):
        super().__init__(ranges, weights, solact_levels)
        self.delta = delta
    
    def loss_measure(self, y_pred, y_true):
        error = y_true - y_pred
        
        is_small_error = error < self.delta
        small_error_loss = (0.5 * (error ** 2))
        large_error_loss = (self.delta * (torch.abs(error) - 0.5 * self.delta))

        return torch.where(is_small_error, small_error_loss, large_error_loss)

# %% ../nbs/losses.ipynb 9
class ClassificationLoss(Loss):
    def __init__(self, ranges, solact_levels, loss):
        n_variables = ranges.shape[1]
        weights = np.arange(n_variables)

        super().__init__(ranges, weights, solact_levels)

        self.loss_measure = loss.loss_measure

    def forward(self, y_pred, y_true):
        error = self.loss_measure(self, y_pred, y_true)
        weights = 1 + torch.abs(self.weighted_loss_tensor(y_true) - self.weighted_loss_tensor(y_pred))
        loss = (error * weights).mean()
        
        return loss

# %% ../nbs/losses.ipynb 10
class TrendedLoss(nn.Module):
    def __init__(self, loss):
        super().__init__()
        self.loss_measure = loss.loss_measure

    def _slope(self, y):
        x = np.arange(len(y))
        slope, _ = np.polyfit(x, y, deg=1)
        return slope

    def forward(self, y_pred, y_true):
        device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
        reshaped_input = y_pred.reshape(1,4,-1)
        reshaped_target = y_true.reshape(1,4,-1)

        input_trend, target_trend = [], []

        for i in range(y_pred.shape[1]):
            input_trend.append(self._slope(reshaped_input[0,i,:].cpu().detach().numpy()))
            target_trend.append(self._slope(reshaped_target[0,i,:].cpu().detach().numpy()))

        trend_diff = torch.abs(torch.Tensor(input_trend) - torch.Tensor(target_trend)).to(device)

        pct_var = self.loss_measure(self, y_pred, y_true)
        out = (pct_var * trend_diff.reshape(1,4,1)).to(device)
        loss = out.mean()

        return loss.cpu()

# %% ../nbs/losses.ipynb 12
class LossMetrics:
    def __init__(self, loss_func:Loss):
        self.loss_func = loss_func

    def loss_call(self, input, target, weight_idx):
        loss_copy = deepcopy(self.loss_func)

        for idx in range(len(loss_copy.weights)):
            if idx != weight_idx:
                loss_copy.weights[idx] = 0
        
        return loss_copy(input, target)

    def loss_low(self, input, target):
        return self.loss_call(input, target, 0)

    def loss_moderate(self, input, target):
        return self.loss_call(input, target, 1)

    def loss_elevated(self, input, target):
        return self.loss_call(input, target, 2)

    def loss_high(self, input, target):
        return self.loss_call(input, target, 3)

    def metrics(self):
        return [self.loss_low, self.loss_moderate, self.loss_elevated, self.loss_high]
