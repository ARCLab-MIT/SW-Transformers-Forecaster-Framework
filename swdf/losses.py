# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/losses.ipynb.

# %% auto 0
__all__ = ['Loss', 'wMSELoss', 'wMAELoss']

# %% ../nbs/losses.ipynb 0
import torch
import numpy as np
import pandas as pd
from tsai.basics import *


# %% ../nbs/losses.ipynb 2
class Loss(nn.Module):
    def __init__(self, ranges, weights, solact_levels):
        super().__init__()
        self.register_buffer('ranges', torch.Tensor(ranges))
        self.register_buffer('weights', torch.Tensor(weights))
        self.solact_levels = solact_levels

    def weighted_loss_tensor(self, target):        
        batch, variables, horizon = target.shape  # Example shape (32, 4, 6)
        variable, range, interval = self.ranges.shape  # Example shape (4, 4, 2)

        target_shaped = torch.reshape(target, (batch, variables, 1, horizon))  # Example shape (32, 4, 6) -> (32, 4, 1, 6)
        ranges_shaped = torch.reshape(self.ranges, (variable, range, 1, interval))  # Example shape (4, 4, 2) -> (4, 4, 1, 2)

        weights_tensor = ((ranges_shaped[..., 0] <= target_shaped) & (target_shaped <= ranges_shaped[..., 1])).float()
        
        return torch.einsum('r,bvrh->bvh', self.weights, weights_tensor)
    
    def loss_call(self, input, target, weight_idx):
        loss_copy = deepcopy(self)
        
        for i in range(len(loss_copy.weights)):
            if i != weight_idx:
                loss_copy.weights[i] = 0

        return loss_copy(input, target)

    def metrics(self):
        metrics = []
        for i, name in enumerate(['low', 'moderate', 'elevated', 'high']):
            metric = lambda input, target, i=i: self.loss_call(input, target, i)
            metric.__name__ = name
            metrics.append(metric)
        return metrics
    
    def loss_measure(self, y_pred, y_true):
        return NotImplementedError
    
    def forward(self, y_pred, y_true):
        error = self.loss_measure(y_pred, y_true)
        weights = self.weighted_loss_tensor(y_true)
        loss = (error * weights).mean()
        
        return loss

# %% ../nbs/losses.ipynb 4
class wMSELoss(Loss):
    def __init__(self, ranges, weights, solact_levels):
        super().__init__(ranges, weights, solact_levels)

    
    def loss_measure(self, y_pred, y_true):
        return (y_true-y_pred)**2

# %% ../nbs/losses.ipynb 5
class wMAELoss(Loss):
    def __init__(self, ranges, weights, solact_levels):
        super().__init__(ranges, weights, solact_levels)

    
    def loss_measure(self, y_pred, y_true):
        return torch.abs(y_true-y_pred)
